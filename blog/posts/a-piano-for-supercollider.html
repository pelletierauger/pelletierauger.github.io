<!-- year -->2020
<!-- month -->02
<!-- day -->25
<!-- fr-title -->Un piano pour SuperCollider
<!-- fr-html-title -->Un piano <span class="italic8"><span class="small-title">pour</span></span> SuperCollider
<!-- fr-description -->Code complet du projet et documentation.
<!-- fr-content -->

<pn>
    <sc>L'hiver dernier</sc>, j'ai commencé à construire un échantillonneur de piano acoustique dans SuperCollider. Les premières versions du projet avaient plusieurs problèmes de fonctionnement et ma connaissance limitée de <ic>sclang</ic> me rendait la tâche assez ardue. J'ai depuis beaucoup joué avec l'échantillonneur et j'en ai amélioré le code au fil du temps. Je compte encore y travailler sporadiquement mais je me suis dit qu'il était déjà dans un état <i>présentable</i> et qu'il pourrait peut-être servir aux intéressé&middot;e&middot;s. Alors le voici.
</pn>
<p>
    L'instrument utilise <a href="https://freesound.org/people/Samulis/packs/21055/">une collection &nbsn;d'échantillons</a><snl label="etude">J'avais utilisé ces mêmes échantillons pour la trame sonore de mon court métrage <a href="https://www.youtube.com/watch?v=sOEmaJY6h6M"><i8>Étude pour automates cellulaires no. 2</i8></a>. J'avais composé ce morceau avec Ableton Live parce que je ne connaissais pas SuperCollider à ce moment-là. Le morceau n'utilise d'ailleurs qu'un ou deux échantillons différents parce que j'avais constaté que la construction d'un bon échantillonneur avec Ableton Live était <i8>grosso modo</i8> un cauchemar. J'ai plus tard réutilisé ces échantillons de piano dans <a href="https://www.youtube.com/watch?v=COeC7UdIBn8">cette expérience de programmation en direct</a> qui est un de mes premiers projets réalisés avec SuperCollider.</snl>qui est dans le domaine public et que vous pouvez télécharger sur <a href="https://freesound.org/">freesound.org</a>. Il vous faudra vous créer un compte pour faire le téléchargement, mais la création d'un compte ainsi que les téléchargements sont gratuits. Il s'agit d'un excellent site Web que je recommande fortement.
</p>
<p>
    Vous trouverez ci-dessous la totalité du code de l'échantillonneur ainsi que deux exemples de <ic>Pbind</ic> servant à faire une courte démonstration de l'instrument. Il s'agit d'un <sc>logiciel libre</sc> distribué avec une <a href="http://www.apache.org/licenses/LICENSE-2.0.txt">licence Apache <lnum>2.0</lnum></a>. Vous pouvez aussi <a href="">consulter ce code sur GitHub</a>.
</p>

<supercollider>
// Run this block of code once the server is booted.
// You also need to make sure that the packLocation variable
// is set to the actual location of the downloaded sample pack.

(
var pianoSamples, pianoFolder, makeLookUp, indices, pitches, dynAmnt, maxDyn, maxNote,
packLocation = "/21055__samulis__vsco-2-ce-keys-upright-piano/",
quiet = false;

dynAmnt = if (quiet, {2}, {3});
maxDyn = if (quiet, {1}, {2});
maxNote = if (quiet, {46}, {1e2});
pianoSamples = Array.new;
pianoFolder = PathName.new(packLocation);
pianoFolder.entries.do({
    |path, i|
    if (i < maxNote, {
        pianoSamples = pianoSamples.add(Buffer.read(s, path.fullPath));
    });
});

makeLookUp = {
    |note, dynamic|
    var octave = floor(note / 12) - 2;
    var degree = note % 12;
    var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
    var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
    var dynamicOffset = dynamic * 23;
    var sampleToGet = octave * 3 + sampledNote[degree] + dynamicOffset;
    var pitch = noteDeltas[degree];
    [sampleToGet, pitch];
};
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;

Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});

SynthDef(\pianoSynth, {
    arg buf = pianoSamples[0], rate = 1, spos = 0, pan = 0, amp = 1, out = 0, atk = 0, sus = 0, rel = 8;
    var sig, env;
    env = EnvGen.kr(Env.new([0, 1, 1, 0], [atk, sus, rel]), doneAction: 2);
    sig = PlayBuf.ar(2, buf, rate * BufRateScale.ir(buf), startPos: spos, doneAction: 2);
    sig = sig * amp * 18 * env;
    sig = Balance2.ar(sig[0], sig[1], pan, 1);
    Out.ar(out, sig);
}).add;
)

// Below are examples of patterns that show how to use the instrument.
// I recommend running both patterns at the same time,
// they are made to complement each other.

(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
var key = 62 + 36;
var notes = key + [2, -5, 0, -2];
~pianoRiff2.stop;
~pianoRiff2 = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([0.25, 1.75], inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 1, 1, 1], inf),
    \amp, Pseq([0.5, 1, 1, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
~pianoRiff.stop;
~pianoRiff2.stop;
)
</supercollider>

<h3>Utilisation de l'échantillonneur</h3>

<pn>
    <sc>La plupart des utilisateurs</sc> de SuperCollider pourront probablement faire usage de l'échantillonneur sans difficulté, mais j'ai pensé qu'il pourrait tout de même être utile de rédiger quelques instructions, particulièrement pour les débutants à qui les projets bien documentés peuvent beaucoup servir. Il s'agit aussi d'une opportunité de parler des multiples décisions prises lors de la création de l'instrument, et des divers moyens par lesquels il pourrait encore être amélioré.
</pn>
<!-- read-more -->
<p>
    Mon but premier avec ce projet était de jouer du piano avec des séquences générées avec <ic>Pbind</ic>, et de pouvoir écrire ces séquences avec une syntaxe qui ne soit pas obstruée par le mécanisme interne de l'instrument. Voici un <ic>Pbind</ic> qui utilise toutes les fonctionnalités de l'échantillonneur :
</p>

<supercollider>
(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)
</supercollider>

<pn>
    L'instrument se joue à l'aide d'un type d'évènement nommé <ic>\pianoEvent</ic>. Cet évènement gère toute les opérations logiques nécessaires à l'instrument et garde tout cela hors du <ic>Pbind</ic>. Les notes que vous voulez jouer doivent être définies avec la valeur &nbsn;<ic>\num</ic>.<snr label="num">Je voulais utiliser la valeur <ic8>\note</ic8>, pour que la nomenclature soit plus claire, mais <ic8>Pbind</ic8> semble avoir une fonctionnalité interne particulière pour cette valeur.</snr> Les notes peuvent aller de <ic>20</ic> à <ic>110</ic>. Il s'agit de valeurs <sc>midi</sc> standards, <ic>20</ic> étant un <lnum>sol#-1</lnum> et <ic>110</ic> étant un ré8. L'instrument possède aussi quelques &ldquo;mesures de sécurité&rdquo;, ainsi si vous demandez une note inférieure à <ic>20</ic> ou supérieure à <ic>110</ic>, la note disponible la plus près sera plutôt jouée (donc <ic>20</ic> ou <ic>110</ic>). Les notes négatives seront transformées en la note <ic>20</ic>. Détail intéressant, si vous demandez une note qui n'est pas un nombre entier, tel que <ic>50.5</ic>, l'instrument jouera une note entre <ic>50</ic> et <ic>51</ic>. Toute valeur fractionnelle fonctionne, ce qui permet d'utiliser cet instrument pour faire de la musique microtonale.
</pn>
<p>
    Chaque note dans la collection d'échantillons existe en trois différents niveaux de dynamique : doux, moyen et fort. La dynamique d'une note est définie par la valeur <ic>\dyn</ic> dans le <ic>Pbind</ic>. <ic>\dyn</ic> peut être <ic>0</ic>, <ic>1</ic> ou <ic>2</ic>. Les mesures de sécurité arrondissent la valeur <ic>\dyn</ic> au nombre entier le plus bas, ainsi une valeur de <ic>0.9</ic> devient <ic>0</ic>. Une valeur supérieure à <ic>2</ic> devient <ic>2</ic>, et une valeur négative devient <ic>0</ic>. Un <ic>Pbind</ic> qui n'inclut aucune définition pour la valeur <ic>\dyn</ic> jouera des notes avec une dynamique de <ic>0</ic>.
</p>
<p>
    La valeur <ic>\amp</ic> dans le <ic>Pbind</ic> est simplement multipliée à l'amplitude des notes jouées. Elle n'a aucun effet sur la dynamique des notes. L'instrument a aussi d'autres valeurs optionnelles : <ic>atk</ic>, <ic>sus</ic> et <ic>rel</ic>, pour <i>attack</i>, <i>sustain</i> et <i>release</i>. Ces valeurs peuvent être utiles surtout parce que les échantillons ont une quantité non négligeable de bruit de fond, alors il peut être intéressant de diminuer la durée de jeu des notes afin de diminuer la quantité de bruit de fond qui s'accumule rapidement lorsque beaucoup de notes sont jouées simultanément.
</p>

<h3>Le mode <ic>quiet</ic></h3>

<pn>
    <sc>Dans les premières lignes</sc> du code de l'instrument, on peut lire ceci : <ic>quiet = false</ic>. Si vous changez cette valeur pour <ic>true</ic> avant d'évaluer le code, les échantillons les plus forts ne seront pas mis en mémoire et ne seront donc pas disponibles. J'ai écrit cette option parce que je n'utilise personnellement jamais ces échantillons. J'écris surtout de la musique assez calme et je ne me sers jamais de sons très lourds ou intenses, alors charger ces échantillons serait pour moi un gaspillage de mémoire (un gaspillage assez petit, mais un gaspillage tout de même). Dans ce mode <ic>quiet</ic>, une valeur <ic>\dyn</ic> au-dessus de <ic>1</ic> dans un <ic>Pbind</ic> sera transformée en <ic>1</ic>, parce que les échantillons avec une dynamique de <ic>2</ic> ne seront pas disponibles.
</pn>

<h3>Fonctionnement du programme</h3>

<pn>
    <sc>La collection d'échantillons</sc> contient trois notes enregistrées pour chaque octave : do#, fa et la. Le <i>modus operandi</i> du programme consiste à prendre la note qu'on lui demande de jouer et à trouver l'enregistrement qui en est le plus près. Ensuite, si l'enregistrement trouvé par le programme n'est pas la note exacte dont l'utilisateur a fait la demande, le programme devra jouer cet enregistrement à une vitesse différente afin de produire la note voulue. Par exemple, si vous demandez un do, le programme jouera l'enregistremnt du do# à une vitesse de <span class="constrain-line"><im>\big(2^{1/12}\big)^{-1}</im></span> puisque la note voulue est à une distance de <im>-1</im> de la note &nbsn;enregistrée.<snl label="temperament"> Ce bout de mathématique provient de la construction de la <a href="https://fr.wikipedia.org/wiki/Gamme_temp%C3%A9r%C3%A9e">gamme tempérée</a>.</snl> Similairement, toute distance <im>n</im> entre la note voulue et la note enregistrée qui en est le plus près résultera en un jeu de la note enregistrée à une vitesse de <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span>.
</pn>
<p>
    Dans le bout de code ci-dessous, on peut voir comment chaque octave est construit, en partant de la note do. Dans la variable <ic>sampledNote</ic>, nous définissons quel échantillon sera utilisé pour chaque degrée de l'octave : do# est représenté par le nombre <ic>1</ic>, fa par le nombre <ic>2</ic> et la par le nombre <ic>3</ic>. Dans la variable <ic>noteDeltas</ic>, nous définissions la distance (ou l'intervalle) entre la note voulue et la note enregistrée qui est en le plus près. Il est donc logique d'observer que pour les notes do#, fa et la, la valeur associée dans <ic>noteDeltas</ic> est <ic>0</ic>. Et puisque <span class="constrain-line"><im>\big(2^{1/12}\big)^{0} = 1</im></span>, ces notes seront jouées à une vitesse de <ic>1</ic>.
</p>

<supercollider>
var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
</supercollider>

<pn>
    Ces deux lignes de code se trouvent dans la fonction <ic>makeLookUp()</ic>, qui est utilisée pour créer deux tables de correspondance dont l'instrument se &nbsn;servira.<snr label="lookup">Une table de correspondance sert à préparer de l'information qui sera fréquemment utilisée, ce qui est plus optimal qu'utiliser à répétition un algorithme qui renvoit à chaque fois la même information. Dans le cas présent, les calculs que l'instrument doit faire pour chaque note sont très simples et rapides, mais j'ai tout de même trouvé qu'il était intéressant de structurer le programme avec des tables de correspondance, et de le rendre théoriquement plus optimisé, même si le gain de performance n'est vraiment pas observable (mais bon, ce que je voulais c'était surtout apprendre à faire des tables de correspondance et m'amuser avec ça).</snr> Dans les lignes ci-dessous, cette fonction <ic>makeLookUp()</ic> est finalement utilisée pour créer deux tables de correspondance : la première qui associe chaque note à l'échantillon enregistré qui sera utilisé, et la seconde qui associe chaque note à la vitesse à laquelle cet échantillon sera joué. Vous pouvez voir deux boucles imbriquées : la boucle extérieure qui se fait avec la valeur <ic>dynAmnt</ic>, qui représente la quantité de dynamiques disponibles, et la boucle intérieure qui se fait avec une liste (<ic>Array</ic>) qui va de <ic>20</ic> jusqu'à <ic>110</ic>, ce qui représente toutes les notes jouables.
</pn>

<supercollider>
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;
</supercollider>

<pn>
    C'est dans l'évènement <ic>\pianoEvent</ic> que les tables de correspondance sont ensuite utilisées. C'est aussi là que les valeurs définies dans un <ic>Pbind</ic> sont testées et remplacées au besoin par des valeurs différentes (l'étendue des variables <ic>~num</ic> et <ic>~dyn</ic> est limitée par les opérateurs <ic>min()</ic> et &nbsn;<ic>max()</ic>).<snl label="envir">C'est assez mêlant tout ça, mais les valeurs qui sont définies dans un <ic8>Pbind</ic8>, comme <ic8>\num</ic8> and <ic8>\dyn</ic8>, elles deviennent les variables <ic8>~num</ic8> et <ic8>~dyn</ic8> à l'intérieur de l'évènement que le <ic8>Pbind</ic8> active. Le tilde (<ic8>~</ic8>) qui précède le nom de ces variables signifie qu'elles sont des &ldquo;variables d'environnement&rdquo; (<i8>environment variables</i8>), cet environnement étant l'évènement <ic8>\pianoEvent</ic8>.</snl>
</pn>

<supercollider>
Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});
</supercollider>

<pn>
    La microtonalité est aussi calculée dans <ic>\pianoEvent</ic>, à la ligne où est définie la valeur <ic>~rate</ic>. En calculant la valeur fractionnelle de la valeur <ic>~num</ic> (avec l'opérateur <ic>frac()</ic>), et en l'additionnant à la distance entre la note voulue et la note enregistrée (distance calculée précédemment lors de la création des tables de correspondance), on obtient la distance finale exacte entre la note voulue et la note disponible. On envoie ensuite cette distance dans l'opérateur <ic>midiratio</ic>, qui fait le même calcul mentionné plus haut : <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span> où <im>n</im> est la valeur de départ.
</pn>

<h3>
    Différentes façons de gérer les dynamiques
</h3>

<pn>
    <sc>Un des moyens</sc> par lesquels cet instrument pourrait être amélioré consisterait à créer un meilleur système pour gérer les dynamiques. The current system of manually selecting which of the three samples (quiet, medium, or loud) is used, is somewhat clunky. What happens if you want to gradually increase the dynamics of a pattern, or if you just want a note between quiet and medium? It's definitely possible, but you have to carefully think about which sample will be played at which amplitude, and create all the necessary lists to express your idea. Here is one example of a pattern that gets repeated at gradually increasing dynamics:
</pn>

<supercollider>
(
var n = 20;
var r = -1 / n;
var decrease = Pseries(1, r, n).asStream.nextN(n);
var increase = decrease.reverse * 0.75;
var amplitudes = [decrease, increase].lace(n * 2);
~crescendoRiff.stop;
~crescendoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([1, 1, 2, 3, 1].stutter(2) * 0.25 * 0.35, inf)
    * Pseq([0, 1], inf),
    \num, 62 
    + Pseq(([0, 7, 4, 11, 9] ++ [-3, 4, 2, 9, 4]).stutter(2), inf)
    + Pseq([0, -5].stutter(n * 4), inf),
    \dyn, Pseq([0, 1], inf) + Pseq([0, 1].stutter(n * 2), inf),
    \amp, Pseq(amplitudes ++ (amplitudes * 0.75), inf) * 0.5,
    \rel, 2
).play();
)  
</supercollider>

<pn>
    We start by creating two lists, one of decreasing values (for the amplitudes of the quiet samples) and one of increasing values (for the amplitudes of the medium samples). We then lace these two lists, creating a single list that will interlace the two streams of quiet and medium notes. And then, in the <ic>\dur</ic> key of the <ic>Pbind</ic>, we multiply our list of durations by <ic>Pseq([0, 1], inf)</ic>, which means that the first note of every pair will have a duration of <ic>0</ic>, which means that two notes will always play simultaneously for each duration set by the first <ic>Pseq</ic> within <ic>\dur</ic>. We then list the notes that we want to play in <ic>\num</ic>, making sure to <ic>stutter()</ic> the list by <ic>2</ic> because each note will be played simultaneously twice.
</pn>
<p>
    And then, in <ic>\dyn</ic>, we create a repeating stream of <ic>[0, 1]</ic>, <ic>0</ic> being the quiet sample and <ic>1</ic> being the medium sample. After <ic>n * 2</ic> times, so after the full gradient of increases and decreases is complete, we add <ic>1</ic> to this pattern with the second <ic>Pseq</ic>. So we end up with a repeating stream of <ic>[1, 2]</ic>, because now we interpolate between the medium sample and the loud sample.
</p>
<p>
    This way of creating a smooth gradient of dynamics is laborious, but there are some reasons for which it isn't necessarily a bad system. The ideal system would simply take a floating point between <ic>0</ic> and <ic>1</ic> for the <ic>\dyn</ic> key, and automatically play two samples at varying amplitudes, creating the interpolated dynamics. <ic>0</ic> would be the quietest and <ic>1</ic> the loudest. But this ideal system is difficult to build without creating unintended problems. First of all, playing two samples simultaneously, particularly when you let them ring for a long time, can create subtle phasing effects. These may be acceptable or not depending on the context. And also, there are some irregularities in the sample pack, certain notes were recorded at slightly different dynamics or slightly different &nbsn;amplitudes.<snr label="exceptions">A careful list of &ldquo;exceptions&rdquo; could be created to manually change the amplitude of certain samples and bring them all to a more unified level, but this is beginning to feel like the work that I would do if I end up using this instrument with this specific sample pack for years and years.</snr> So when I create patterns, I enjoy the possibility of manually defining which sample will play at which amplitude. It's the more complicated way of doing things, but also the way that offers the most control.
</p>
<p>
    So I decided not to create a system of floating point dynamics for now. Maybe I'll do it at some point, or maybe <i>you will</i>.
</p>

<h3>En conclusion</h3>

<pn>
    <sc>J'ai eu beaucoup de plaisir</sc> à créer ce projet et il m'a permis d'apprécier plus profondément l'étrange et confondante beauté de <ic>sclang</ic>. Si vous utilisez l'échantillonneur, il me ferait plaisir d'en recevoir des échos et aussi d'entendre vos compositions. N'hésitez pas à <a href="https://pelletierauger.com/fr/a-propos.html#contact">me contacter</a> pour des commentaires ou des questions.
</pn>
<p>
    Je vous laisse avec un dernier <ic>Pbind</ic>, qui est une variante de celui plus haut qui servait à démontrer une technique pour obtenir une montée graduelle des dynamiques. Merci de votre lecture !
</p>

<supercollider>
(
var n = 40;
var r = -1 / n;
var decrease = Pseries(1, r, n).asStream.nextN(n);
var increase = decrease.reverse * 0.75;
var amplitudes = [decrease, increase].lace(n * 2);
~crescendoRiff.stop;
~crescendoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([2, 1, 2, 3, 1].stutter(2) * 0.25 * 0.1, inf)
    * Pseq([0, 1], inf),
    \num, 72
    + Pseq(([0, 7, 4, 11, 9] ++ [-3, 4, 2, 9, 4]).stutter(2).reverse, inf)
    + Pseq([0, -5].stutter(n * 8), inf)
    + Pseq(
        ((0!(n * 1 - 1) ++ (19!1)) ++ (0!(n * 1 - 1) ++ (21!1))).stutter(2).wrapExtend(n * 8) ++
        ((0!(n * 1 - 1) ++ (28!1)) ++ (0!(n * 1 - 1) ++ (26!1))).stutter(2).wrapExtend(n * 8)
    , inf)
    - Pseq(
        ([36 - 5] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 - 3] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 - 0] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 + 4] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4)
    , inf),
    \dyn, Pseq([0, 1], inf) + Pseq([0].stutter(n * 2), inf)
    + Pseq((0!(n * 2 - 1) ++ (0!1)).stutter(2), inf)
    + Pseq(([1] ++ (0!(n * 2 - 1))).stutter(2), inf),
    \amp, Pseq(amplitudes ++ (amplitudes * 0.75), inf) * 0.5
    * Pseq(1!(n * 2 - 1) ++ (2!1), inf),
    \rel, 4 * Pseq((1!(n * 2 - 1) ++ (2!1)).stutter(2), inf)
).play();
)
</supercollider>

<!-- en-title -->A Piano for SuperCollider
<!-- en-html-title -->A Piano <span class="italic8"><span class="small-title">for</span></span> SuperCollider
<!-- en-description -->Complete code for the project and some documentation.
<!-- en-content -->

<pn>
    <sc>Last winter</sc>, I started to work on an acoustic piano multi-sampler for SuperCollider. The earliest versions had many issues, and my budding programming skills in <ic>sclang</ic> did not allow me to fix them. But I've used the instrument a lot since then, and I've improved the code along the way. I plan to keep working on the instrument as I keep using it, but I'm thinking that it could already be useful for other people if they are interested. So here it is.
</pn>
<p>
    The instrument uses <a href="https://freesound.org/people/Samulis/packs/21055/">a public domain sample &nbsn;pack</a><snl label="etude">I used this same sample pack for a piece of music that I wrote for my short film <a href="https://www.youtube.com/watch?v=sOEmaJY6h6M"><i8>Étude for Cellular Automata no 2</i8></a>. I composed this piece with Ableton Live because I didn't know about SuperCollider at the time. The piece uses only one or two samples in the pack, as I had found that building a good multi-sampler with Ableton Live was mostly a nightmare. I also used the piano samples in <a href="https://www.youtube.com/watch?v=COeC7UdIBn8">this live coding experiment</a> which was one of my first SuperCollider projects.</snl>that you can download from <a href="https://freesound.org/">freesound.org</a>. You'll need to create an account to download it, but it's free to join, and free to download, and I highly recommend this website.
</p>
<p>
    Below is the entirety of the code for the sampler, along with some <ic>Pbind</ic> examples to try it out. It is <sc>free software</sc> distributed under an <a href="http://www.apache.org/licenses/LICENSE-2.0.txt">Apache <lnum>2.0</lnum> licence</a>. You can also <a href="">find this code on GitHub</a>.
</p>

<supercollider>
// Run this block of code once the server is booted.
// You also need to make sure that the packLocation variable
// is set to the actual location of the downloaded sample pack.

(
var pianoSamples, pianoFolder, makeLookUp, indices, pitches, dynAmnt, maxDyn, maxNote,
packLocation = "/21055__samulis__vsco-2-ce-keys-upright-piano/",
quiet = false;

dynAmnt = if (quiet, {2}, {3});
maxDyn = if (quiet, {1}, {2});
maxNote = if (quiet, {46}, {1e2});
pianoSamples = Array.new;
pianoFolder = PathName.new(packLocation);
pianoFolder.entries.do({
    |path, i|
    if (i < maxNote, {
        pianoSamples = pianoSamples.add(Buffer.read(s, path.fullPath));
    });
});

makeLookUp = {
    |note, dynamic|
    var octave = floor(note / 12) - 2;
    var degree = note % 12;
    var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
    var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
    var dynamicOffset = dynamic * 23;
    var sampleToGet = octave * 3 + sampledNote[degree] + dynamicOffset;
    var pitch = noteDeltas[degree];
    [sampleToGet, pitch];
};
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;

Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});

SynthDef(\pianoSynth, {
    arg buf = pianoSamples[0], rate = 1, spos = 0, pan = 0, amp = 1, out = 0, atk = 0, sus = 0, rel = 8;
    var sig, env;
    env = EnvGen.kr(Env.new([0, 1, 1, 0], [atk, sus, rel]), doneAction: 2);
    sig = PlayBuf.ar(2, buf, rate * BufRateScale.ir(buf), startPos: spos, doneAction: 2);
    sig = sig * amp * 18 * env;
    sig = Balance2.ar(sig[0], sig[1], pan, 1);
    Out.ar(out, sig);
}).add;
)

// Below are examples of patterns that show how to use the instrument.
// I recommend running both patterns at the same time,
// they are made to complement each other.

(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
var key = 62 + 36;
var notes = key + [2, -5, 0, -2];
~pianoRiff2.stop;
~pianoRiff2 = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([0.25, 1.75], inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 1, 1, 1], inf),
    \amp, Pseq([0.5, 1, 1, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)

(
~pianoRiff.stop;
~pianoRiff2.stop;
)
</supercollider>

<h3>How to use the sampler</h3>

<pn>
    <sc>Using the instrument</sc> will probably be very straightforward for most users of SuperCollider, but I thought that writing down some instructions could still be useful, particularly for beginners. It's also an opportunity to talk about the design decisions that went into creating the instrument, and the ways in which it could potentially be improved.
</pn>
<!-- read-more -->
<p>
    My main goal for this project was to use the piano with instances of <ic>Pbind</ic> that would be as uncluttered as possible. Here is a <ic>Pbind</ic> that uses all features of the instrument:
</p>

<supercollider>
(
var key = 62;
var notes = key + ([0, 3, 7, 10] ++ [-5, 2, 3, 9]);
~pianoRiff.stop;
~pianoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq(0.5!1 ++ (0.25!3), inf),
    \num, Pseq(notes, inf),
    \dyn, Pseq([1, 0, 0, 1], inf),
    \amp, Pseq([0.5, 2, 2, 0.5], inf),
    \pan, Pwhite(-0.75, 0.75, inf),
    \rel, 4
).play(quant: [2]);
)
</supercollider>

<pn>
    The instrument is played by using a custom event type named <ic>\pianoEvent</ic>. This event type computes all the logic behind the instrument and leaves all of that out of the <ic>Pbind</ic>. The notes that you want to play must be defined with the <ic>\num</ic> &nbsn;key.<snr label="num">I wanted to use the <ic8>\note</ic8> key but <ic8>Pbind</ic8> seems to have some internal functionality for this key.</snr> The notes can be between <ic>20</ic> and <ic>110</ic>. These are standard <sc>midi</sc> note values, <ic>20</ic> being a G#-1 and <ic>110</ic> being a D8. There are &ldquo;safety measures&rdquo; in the instrument, so if you ask for notes below <ic>20</ic> or above <ic>110</ic> it'll give you the closest available note (so <ic>20</ic> or <ic>110</ic>). Negative notes will return <ic>20</ic>. Notably, if you ask for a non-integer note like <ic>50.5</ic>, it will give you a note between <ic>50</ic> and <ic>51</ic>. Any non-integer values work, which makes this instrument usable for microtonal music.
</pn>
<p>
    Each note in the sample pack exists in three different levels of loudness (or dynamics) from quiet, to medium, to loud. The dynamics of a note is defined by the <ic>\dyn</ic> key in the <ic>Pbind</ic>. <ic>\dyn</ic> can either be <ic>0</ic>, <ic>1</ic>, or <ic>2</ic>. The safety measures will floor this <ic>\dyn</ic> value, so a loudness of <ic>0.9</ic> will return <ic>0</ic>. A loudness above <ic>2</ic> will return <ic>2</ic>, and negative values will return <ic>0</ic>. A <ic>Pbind</ic> that does not include a <ic>\dyn</ic> key will default to a value of <ic>0</ic>.
</p>
<p>
    The <ic>\amp</ic> key in the <ic>Pbind</ic> simply scales the amplitude of the note. It has no effect on which level of dynamics is played. The instrument also has optional <ic>atk</ic>, <ic>sus</ic>, and <ic>rel</ic> arguments, for attack, sustain, and release. These are useful mainly because the noise floor in the samples is quite high, so you may want to limit the duration over which a note is played, to reduce the noise.
</p>

<h3>The <ic>quiet</ic> mode</h3>

<pn>
    <sc>You can see</sc> near the top of the code a line that goes: <ic>quiet = false</ic>. If you change this to <ic>true</ic> before you evaluate the code, it will prevent the loud samples from being loaded. I wrote this option because I personally never use the loud samples. I tend to write quiet music and I don't have much use for loud sounds, so loading them is a waste of memory (perhaps a very small waste, but a waste nonetheless). In this quiet mode, a <ic>\dyn</ic> value above <ic>1</ic> in the <ic>Pbind</ic> will return <ic>1</ic>, because the samples with a dynamic of <ic>2</ic> will not be loaded.
</pn>

<h3>How it all works</h3>

<pn>
    <sc>The sample pack contains</sc> three samples per octave: C#, F, and A. The basic <i>modus operandi</i> of the sampler is to take a note that you want to play and look for the closest note that it can find in the pack. And then, if the closest note is not the exact one that you asked for, the sampler has to play this closest note at a different pitch to produce the desired note. So if you want a C, it will play the recorded C# note at a pitch ratio of <span class="constrain-line"><im>\big(2^{1/12}\big)^{-1}</im></span> because the desired note is <im>-1</im> note away from the closest &nbsn;note.<snl label="temperament"> This bit of mathematics is how the <a href="https://en.wikipedia.org/wiki/Equal_temperament">twelve-tone equal temperament</a> is built.</snl> Any distance <im>n</im> between the desired note and the available note will similarly result in the available note being played at a ratio of <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span> to obtain the desired note.
</pn>
<p>
    In the code box below you can see how each octave is built, starting on the note C. For each degree of the octave, we define which sample will be used in the <ic>sampledNote</ic> variable: C# is <ic>1</ic>, F is <ic>2</ic>, and A is <ic>3</ic>. In the <ic>noteDeltas</ic> variable, we define the distance (or interval) between the note that we want, and the closest available note. So it follows that for C#, F, and A, the value in <ic>noteDeltas</ic> is <ic>0</ic>. And since <span class="constrain-line"><im>\big(2^{1/12}\big)^{0} = 1</im></span>, these notes will be played at a pitch ratio of <ic>1</ic>.
</p>

<supercollider>
var sampledNote = [1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  3,  3];
var noteDeltas = [-1, 0,  1,  2, -1,  0,  1, -2, -1,  0,  1,  2];
</supercollider>

<pn>
    These two lines of code are found in the <ic>makeLookUp()</ic> function, which is used to create two lookup tables that will then be used when the instrument is &nbsn;played.<snr label="lookup">The purpose of a lookup table is to prepare data that will be used frequently instead of running an algorithm that generates the same data every time. In this case, the calculations are really simple and fast, but I thought that lookup tables were still an interesting way to organize the program and make it theoretically even faster (but mostly I just wanted to experiment with lookup tables).</snr> The lines below is where we run this <ic>makeLookUp()</ic> function and build the two lookup tables, one for the indices of the available closest buffers and one for the pitch ratios at which the notes will be played. You can see two nested loops here: one loop over the <ic>dynAmnt</ic> value, which is the amount of different dynamics that will be available, and the other loop over an <ic>Array</ic> that goes from <ic>20</ic> to <ic>110</ic>, which is a list of all available notes.
</pn>

<supercollider>
indices = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[0]})}).flat;
pitches = dynAmnt.collect({|j| (20..110).collect({|i| makeLookUp.(i, j)[1]})}).flat;
</supercollider>

<pn>
    The <ic>\pianoEvent</ic> event type is where the lookup tables are used. It's also where the numbers defined in a <ic>Pbind</ic> are sanitized (you can see the <ic>~num</ic> and <ic>~dyn</ic> variables being constrained with <ic>min()</ic> and <ic>max()</ic> &nbsn;operators),<snl label="envir">It's confusing but the keys that were defined in the <ic8>Pbind</ic8>, like <ic8>\num</ic8> and <ic8>\dyn</ic8>, they are referred to as <ic8>~num</ic8> and <ic8>~dyn</ic8> within the <ic8>Event</ic8> that the <ic8>Pbind</ic8> activates. The <ic8>~</ic8> before the variable names means that they are environment variables, the environment being the <ic8>Event</ic8> itself.</snl> and where the microtonality is made possible.
</pn>

<supercollider>
Event.addEventType(\pianoEvent, {
    var index;
    if (~num.isNil, {~num = 60}, {~num = min(max(20, ~num), 110)});
    if (~dyn.isNil, {~dyn = 0}, {~dyn = floor(min(max(0, ~dyn), maxDyn))});
    index = floor(~num) - 20 + (~dyn * 91);
    ~buf = pianoSamples[indices[index]];
    ~rate = (pitches[index] + frac(~num)).midiratio;
    ~instrument = \pianoSynth;
    ~type = \note;
    currentEnvironment.play;
});
</supercollider>

<pn>
    The microtonality is calculated on the line where the variable <ic>~rate</ic> is defined. By taking the fractional value of <ic>~num</ic> and by adding it to the &ldquo;note delta&rdquo; that was previously computed in the creation of the lookup table, we obtain the final distance between the desired note and the available note, and we pass this distance to the <ic>midiratio</ic> operator, which is doing the same calculation as above: <span class="constrain-line"><im>\big(2^{1/12}\big)^{n}</im></span> where <im>n</im> is the input. This fractional value is only present when the notes you ask for are not integers&mdash;when you are playing with microtonality.
</pn>

<h3>
    Different ways of handling dynamics
</h3>

<pn>
    <sc>One of the ways</sc> I can think of improving this instrument is creating a better system to handle dynamics. The current system of manually selecting which of the three samples (quiet, medium, or loud) is used, is somewhat clunky. What happens if you want to gradually increase the dynamics of a pattern, or if you just want a note between quiet and medium? It's definitely possible, but you have to carefully think about which sample will be played at which amplitude, and create all the necessary lists to express your idea. Here is one example of a pattern that gets repeated at gradually increasing dynamics:
</pn>

<supercollider>
(
var n = 20;
var r = -1 / n;
var decrease = Pseries(1, r, n).asStream.nextN(n);
var increase = decrease.reverse * 0.75;
var amplitudes = [decrease, increase].lace(n * 2);
~crescendoRiff.stop;
~crescendoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([1, 1, 2, 3, 1].stutter(2) * 0.25 * 0.35, inf)
    * Pseq([0, 1], inf),
    \num, 62 
    + Pseq(([0, 7, 4, 11, 9] ++ [-3, 4, 2, 9, 4]).stutter(2), inf)
    + Pseq([0, -5].stutter(n * 4), inf),
    \dyn, Pseq([0, 1], inf) + Pseq([0, 1].stutter(n * 2), inf),
    \amp, Pseq(amplitudes ++ (amplitudes * 0.75), inf) * 0.5,
    \rel, 2
).play();
)  
</supercollider>

<pn>
    We start by creating two lists, one of decreasing values (for the amplitudes of the quiet samples) and one of increasing values (for the amplitudes of the medium samples). We then lace these two lists, creating a single list that will interlace the two streams of quiet and medium notes. And then, in the <ic>\dur</ic> key of the <ic>Pbind</ic>, we multiply our list of durations by <ic>Pseq([0, 1], inf)</ic>, which means that the first note of every pair will have a duration of <ic>0</ic>, which means that two notes will always play simultaneously for each duration set by the first <ic>Pseq</ic> within <ic>\dur</ic>. We then list the notes that we want to play in <ic>\num</ic>, making sure to <ic>stutter()</ic> the list by <ic>2</ic> because each note will be played simultaneously twice.
</pn>
<p>
    And then, in <ic>\dyn</ic>, we create a repeating stream of <ic>[0, 1]</ic>, <ic>0</ic> being the quiet sample and <ic>1</ic> being the medium sample. After <ic>n * 2</ic> times, so after the full gradient of increases and decreases is complete, we add <ic>1</ic> to this pattern with the second <ic>Pseq</ic>. So we end up with a repeating stream of <ic>[1, 2]</ic>, because now we interpolate between the medium sample and the loud sample.
</p>
<p>
    This way of creating a smooth gradient of dynamics is laborious, but there are some reasons for which it isn't necessarily a bad system. The ideal system would simply take a floating point between <ic>0</ic> and <ic>1</ic> for the <ic>\dyn</ic> key, and automatically play two samples at varying amplitudes, creating the interpolated dynamics. <ic>0</ic> would be the quietest and <ic>1</ic> the loudest. But this ideal system is difficult to build without creating unintended problems. First of all, playing two samples simultaneously, particularly when you let them ring for a long time, can create subtle phasing effects. These may be acceptable or not depending on the context. And also, there are some irregularities in the sample pack, certain notes were recorded at slightly different dynamics or slightly different &nbsn;amplitudes.<snr label="exceptions">A careful list of &ldquo;exceptions&rdquo; could be created to manually change the amplitude of certain samples and bring them all to a more unified level, but this is beginning to feel like the work that I would do if I end up using this instrument with this specific sample pack for years and years.</snr> So when I create patterns, I enjoy the possibility of manually defining which sample will play at which amplitude. It's the more complicated way of doing things, but also the way that offers the most control.
</p>
<p>
    So I decided not to create a system of floating point dynamics for now. Maybe I'll do it at some point, or maybe <i>you will</i>.
</p>

<h3>Final thoughts</h3>

<pn>
    <sc>I really enjoyed</sc> putting this project together and it made me appreciate the strange and often confusing beauty of <ic>sclang</ic> even more. If you end up using the sampler, I'd love to have feedback on it or hear what you make with it. Don't hesitate to <a href="https://pelletierauger.com/en/about.html#contact">contact me</a> with comments or questions.
</pn>
<p>
    I will leave you with one last <ic>Pbind</ic>, a variation on the one above where I demonstrated the ascending gradient of dynamics. Thanks for reading!
</p>
<supercollider>
(
var n = 40;
var r = -1 / n;
var decrease = Pseries(1, r, n).asStream.nextN(n);
var increase = decrease.reverse * 0.75;
var amplitudes = [decrease, increase].lace(n * 2);
~crescendoRiff.stop;
~crescendoRiff = Pbind(
    \type, \pianoEvent,
    \dur, Pseq([2, 1, 2, 3, 1].stutter(2) * 0.25 * 0.1, inf)
    * Pseq([0, 1], inf),
    \num, 72
    + Pseq(([0, 7, 4, 11, 9] ++ [-3, 4, 2, 9, 4]).stutter(2).reverse, inf)
    + Pseq([0, -5].stutter(n * 8), inf)
    + Pseq(
        ((0!(n * 1 - 1) ++ (19!1)) ++ (0!(n * 1 - 1) ++ (21!1))).stutter(2).wrapExtend(n * 8) ++
        ((0!(n * 1 - 1) ++ (28!1)) ++ (0!(n * 1 - 1) ++ (26!1))).stutter(2).wrapExtend(n * 8)
    , inf)
    - Pseq(
        ([36 - 5] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 - 3] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 - 0] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4) ++
        ([36 + 4] ++ (0!(n * 2 - 1))).stutter(2).wrapExtend(n * 4)
    , inf),
    \dyn, Pseq([0, 1], inf) + Pseq([0].stutter(n * 2), inf)
    + Pseq((0!(n * 2 - 1) ++ (0!1)).stutter(2), inf)
    + Pseq(([1] ++ (0!(n * 2 - 1))).stutter(2), inf),
    \amp, Pseq(amplitudes ++ (amplitudes * 0.75), inf) * 0.5
    * Pseq(1!(n * 2 - 1) ++ (2!1), inf),
    \rel, 4 * Pseq((1!(n * 2 - 1) ++ (2!1)).stutter(2), inf)
).play();
)
</supercollider>